/* Copyright (c) FIRST and other WPILib contributors.// Open Source Software; you can modify and/or share it under the terms of// the WPILib BSD license file in the root directory of this project.*/package frc.robot.subsystems;import com.ctre.phoenix6.configs.CANcoderConfiguration;import com.ctre.phoenix6.hardware.CANcoder;import com.revrobotics.CANSparkFlex;import com.revrobotics.CANSparkMax;import com.revrobotics.REVLibError;import com.revrobotics.CANSparkBase.ControlType;import com.revrobotics.RelativeEncoder;import com.revrobotics.SparkPIDController;import com.revrobotics.CANSparkLowLevel.MotorType;import edu.wpi.first.math.controller.SimpleMotorFeedforward;import edu.wpi.first.math.geometry.Rotation2d;import edu.wpi.first.math.kinematics.SwerveModulePosition;import edu.wpi.first.math.kinematics.SwerveModuleState;import edu.wpi.first.wpilibj.Timer;import frc.lib.CANSparkUtil;import frc.lib.OnboardModuleState;import frc.lib.SwerveModuleConstants;import frc.lib.CANSparkUtil.Usage;import frc.robot.Constants;import frc.robot.Constants.SwerveConstants;public class SwerveModule{public int moduleNumber;public double m_angleKP;public double m_angleKI;public double m_angleKD;public double m_angleKFF;private Rotation2d lastAngle;private Rotation2d angleOffset;private CANSparkMax angleMotor;private CANSparkFlex driveMotor;private RelativeEncoder driveEncoder;private RelativeEncoder integratedAngleEncoder;private CANcoder angleEncoder;private final SparkPIDController driveController;private final SparkPIDController angleController;private final SimpleMotorFeedforward feedforward= new SimpleMotorFeedforward(SwerveConstants.driveKS,SwerveConstants.driveKV,SwerveConstants.driveKA);public SwerveModule(int moduleNumber,SwerveModuleConstants moduleConstants){this.moduleNumber=moduleNumber;this.m_angleKP=SwerveConstants.angleKP;this.m_angleKI=SwerveConstants.angleKI;this.m_angleKD=SwerveConstants.angleKD;this.m_angleKFF=SwerveConstants.angleKFF;angleOffset=moduleConstants.angleOffset;angleEncoder=new CANcoder(moduleConstants.cancoderID);angleEncoder.getConfigurator().apply(new CANcoderConfiguration());angleEncoder.getAbsolutePosition().setUpdateFrequency(1);angleMotor=new CANSparkMax(moduleConstants.angleMotorID,MotorType.kBrushless);integratedAngleEncoder=angleMotor.getEncoder();angleController=angleMotor.getPIDController();configAngleMotor();driveMotor=new CANSparkFlex(moduleConstants.driveMotorID,MotorType.kBrushless);driveEncoder=driveMotor.getEncoder();driveController=driveMotor.getPIDController();configDriveMotor();lastAngle=getState().angle;}public SwerveModuleState getState(){return new SwerveModuleState(driveEncoder.getVelocity(),getAngle());}public SwerveModulePosition getPosition(){return new SwerveModulePosition(driveEncoder.getPosition(),getAngle());}public double getRawDriveEncoder(){return driveEncoder.getPosition();}public double getRawTurnEncoder(){return integratedAngleEncoder.getPosition();}public boolean isEncoderDataValid(){return driveMotor.getLastError()==REVLibError.kOk&&angleMotor.getLastError()==REVLibError.kOk;}public void setDesiredState(SwerveModuleState desiredState,boolean isOpenLoop){desiredState= OnboardModuleState.optimize(desiredState,getState().angle);setAngle(desiredState);setSpeed(desiredState,isOpenLoop);}private void setSpeed(SwerveModuleState desiredState,boolean isOpenLoop){if(isOpenLoop){double percentOutput=desiredState.speedMetersPerSecond/Constants.SwerveConstants.maxSpeed;driveMotor.set(percentOutput);}else{driveController.setReference(desiredState.speedMetersPerSecond,ControlType.kVelocity,0,feedforward.calculate(desiredState.speedMetersPerSecond));}}private void setAngle(SwerveModuleState desiredState){Rotation2d angle=(Math.abs(desiredState.speedMetersPerSecond)<=(Constants.SwerveConstants.maxSpeed * 0.01))?lastAngle:desiredState.angle;angleController.setReference(angle.getDegrees(),ControlType.kPosition);lastAngle=angle;}private Rotation2d getAngle(){return Rotation2d.fromDegrees(integratedAngleEncoder.getPosition());}public void pointInDirection(double degrees){angleController.setReference(degrees,ControlType.kPosition);lastAngle=Rotation2d.fromDegrees(degrees);}private void resetToAbsolute(){double absolutePosition=getCanCoder().getDegrees()- angleOffset.getDegrees();integratedAngleEncoder.setPosition(absolutePosition);}public Rotation2d getCanCoder(){return Rotation2d.fromRotations(angleEncoder.getAbsolutePosition().getValue());}private void configAngleMotor(){angleMotor.restoreFactoryDefaults();CANSparkUtil.setCANSparkBusUsage(angleMotor,Usage.kPositionOnly);angleMotor.setSmartCurrentLimit(SwerveConstants.angleContinuousCurrentLimit);angleMotor.setInverted(SwerveConstants.angleInvert);angleMotor.setIdleMode(SwerveConstants.angleNeutralMode);integratedAngleEncoder.setPositionConversionFactor(SwerveConstants.angleConversionFactor);angleController.setP(m_angleKP);angleController.setI(m_angleKI);angleController.setD(m_angleKD);angleController.setFF(m_angleKFF);angleMotor.enableVoltageCompensation(SwerveConstants.voltageComp);angleMotor.burnFlash();Timer.delay(1.0);resetToAbsolute();}private void configDriveMotor(){driveMotor.restoreFactoryDefaults();CANSparkUtil.setCANSparkBusUsage(driveMotor,Usage.kAll);driveMotor.setSmartCurrentLimit(SwerveConstants.driveContinuousCurrentLimit);driveMotor.setInverted(SwerveConstants.driveInvert);driveMotor.setIdleMode(SwerveConstants.driveNeutralMode);driveEncoder.setVelocityConversionFactor(SwerveConstants.driveConversionVelocityFactor);driveEncoder.setPositionConversionFactor(SwerveConstants.driveConversionPositionFactor);driveController.setP(SwerveConstants.driveKP);driveController.setI(SwerveConstants.driveKI);driveController.setD(SwerveConstants.driveKD);driveController.setFF(SwerveConstants.driveKFF);driveMotor.enableVoltageCompensation(SwerveConstants.voltageComp);driveMotor.burnFlash();driveEncoder.setPosition(0.0);}}